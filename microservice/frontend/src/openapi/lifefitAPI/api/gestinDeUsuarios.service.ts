/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ForgottenPasswordDTO } from '../model/forgottenPasswordDTO';
import { LoginDTO } from '../model/loginDTO';
import { PasswordResetDTO } from '../model/passwordResetDTO';
import { RespuestaJWTDTO } from '../model/respuestaJWTDTO';
import { UsuarioDTO } from '../model/usuarioDTO';
import { UsuarioNuevoDTO } from '../model/usuarioNuevoDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class GestinDeUsuariosService {

    protected basePath = 'http://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Actualiza un usuario
     * @param body 
     * @param idUsuario 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public actualizarUsuario(body: UsuarioNuevoDTO, idUsuario: number, observe?: 'body', reportProgress?: boolean): Observable<UsuarioDTO>;
    public actualizarUsuario(body: UsuarioNuevoDTO, idUsuario: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsuarioDTO>>;
    public actualizarUsuario(body: UsuarioNuevoDTO, idUsuario: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsuarioDTO>>;
    public actualizarUsuario(body: UsuarioNuevoDTO, idUsuario: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling actualizarUsuario.');
        }

        if (idUsuario === null || idUsuario === undefined) {
            throw new Error('Required parameter idUsuario was null or undefined when calling actualizarUsuario.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UsuarioDTO>('put',`${this.basePath}/usuario/${encodeURIComponent(String(idUsuario))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Crea un nuevo usuario en el sistema
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public crearUsuario(body: UsuarioNuevoDTO, observe?: 'body', reportProgress?: boolean): Observable<UsuarioDTO>;
    public crearUsuario(body: UsuarioNuevoDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsuarioDTO>>;
    public crearUsuario(body: UsuarioNuevoDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsuarioDTO>>;
    public crearUsuario(body: UsuarioNuevoDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling crearUsuario.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<UsuarioDTO>('post',`${this.basePath}/usuario`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Elimina el usuario.
     * @param idUsuario 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public eliminarUsuario(idUsuario: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public eliminarUsuario(idUsuario: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public eliminarUsuario(idUsuario: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public eliminarUsuario(idUsuario: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUsuario === null || idUsuario === undefined) {
            throw new Error('Required parameter idUsuario was null or undefined when calling eliminarUsuario.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/usuario/${encodeURIComponent(String(idUsuario))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Pide al servicio que cree un enlace para resetear la contraseña de un usuario. El servicio debe enviar un e-mail con el enlace para resetear la contraseña. Si el usuario no existe, la respuesta debe ser la misma que cuando existe, para no dar información acerca de la existencia del usuario en el sistema.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public forgottenPassword(body: ForgottenPasswordDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public forgottenPassword(body: ForgottenPasswordDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public forgottenPassword(body: ForgottenPasswordDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public forgottenPassword(body: ForgottenPasswordDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling forgottenPassword.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/forgottenpassword`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Obtiene un usuario concreto
     * @param idUsuario 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUsuario(idUsuario: number, observe?: 'body', reportProgress?: boolean): Observable<UsuarioDTO>;
    public getUsuario(idUsuario: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsuarioDTO>>;
    public getUsuario(idUsuario: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsuarioDTO>>;
    public getUsuario(idUsuario: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUsuario === null || idUsuario === undefined) {
            throw new Error('Required parameter idUsuario was null or undefined when calling getUsuario.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UsuarioDTO>('get',`${this.basePath}/usuario/${encodeURIComponent(String(idUsuario))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Comprueba las credenciales del usuario y devuelve un JWT si todo fue correcto.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public login(body: LoginDTO, observe?: 'body', reportProgress?: boolean): Observable<RespuestaJWTDTO>;
    public login(body: LoginDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RespuestaJWTDTO>>;
    public login(body: LoginDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RespuestaJWTDTO>>;
    public login(body: LoginDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling login.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<RespuestaJWTDTO>('post',`${this.basePath}/login`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Obtiene la lista de usuarios del sistema
     * @param email 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public obtenerUsuarios(email?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<UsuarioDTO>>;
    public obtenerUsuarios(email?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<UsuarioDTO>>>;
    public obtenerUsuarios(email?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UsuarioDTO>>>;
    public obtenerUsuarios(email?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (email !== undefined && email !== null) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<UsuarioDTO>>('get',`${this.basePath}/usuario`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Resetea la contraseña de un usuario al valor que se indica en el cuerpo si el token de petición es correcto. En caso contrario devuelve un error.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public passwordReset(body: PasswordResetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public passwordReset(body: PasswordResetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public passwordReset(body: PasswordResetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public passwordReset(body: PasswordResetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling passwordReset.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/passwordreset`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
